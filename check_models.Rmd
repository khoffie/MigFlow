--- 
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
always_allow_html: true
---

```{r global_knitr, echo = FALSE, eval = TRUE}

knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      results = "hide",
                      fig.width = 8,
                      fig.asp = 0.7,
                      out.width = "120%")

```

```{r, packages}

library(data.table)
library(sf)
library(ggplot2)
library(MigStat)
library(plotR)
library(kableExtra)
library(patchwork)
source("functions.R")

```

```{r read-data, message = TRUE}

preds_th <- 3
age_lvls <- c("below18", "18-25", "25-30", "30-50", "50-65", "above65")
map_age <- age_lvls ## for maps
use_age <- age_lvls ## for everything else
setwd("~/Documents/GermanMigration/")

data <- read_data("works")
dt <-setnames(data$preds, c("flows", "preds3"), c("actual", "preds"), skip_absent = TRUE)

glm(actual ~ 1 + (log(topop/1e3)) + (log(frompop/1e3)) +log(distance),
    family = poisson,
    data = dt[agegroup == use_age[1]],)

dtm <- melt(dt, measure.vars = c("actual", "preds"))
## order_models(dt)
dt <- dt[agegroup %in% use_age]
dt[, agegroup := factor(agegroup, levels = age_lvls)]
dt[, resid1 := (actual - preds) / preds]
dt[, resid2 := sign(resid1) * log(1 + abs(resid1))]

### order_models(dt_coefs)
dt_coefs <- data$coefs
dt_coefs[, diff := values - inits]

p_clean <- "~/Diss/inst/extdata/clean/"
pop_dt <- fread(file.path(p_clean, "aux_data/age17for.csv"))
setnames(pop_dt, "age_group", "agegroup")
rec_ages(pop_dt)

shp <- setDT(sf::read_sf(file.path(p_clean, "shapes/districts_ext.shp")))
density <- data.table::fread(file.path(p_clean, "aux_data", "density.csv"))

dt[, .(all_actual = sum(actual),
       all_predicted = sum(preds)), keyby = agegroup][
  , rel_diff := (all_actual - all_predicted) / all_actual][]

```

```{r, diff-plt, fig.cap = caption}

caption <- "Distribution of differences between optimal values and initial values."

ggplot(dt_coefs, aes(values)) +
    geom_density() +
    facet_wrap(vars(model), scale = "free") +
    theme_minimal() +
    ggtitle("opti coefs")

ggplot(dt_coefs, aes(values - inits)) +
    geom_density() +
    facet_wrap(vars(model)) +
    theme_minimal() +
    ggtitle("opti - init")

```

```{r data}

## dt
dtm <- melt(dt, measure.vars = c("preds", "resid1", "resid2"), variable.name = "type")
dtm <- melt(dt, measure.vars = c("preds"), variable.name = "type")

net1 <- calculate_net(dt, col = "actual", by = c("year", "agegroup", "model"),
                      long = TRUE, type = "actual")
net2 <- calculate_net(dt, col = "preds", by = c("year", "agegroup", "model"),
                      long = TRUE, type = "preds")
net <- rbind(net1, net2)

net2 <- dcast(net[variable == "net"], region + year + agegroup ~ type)

net[pop_dt, pop := i.german, on = .(region, year, agegroup)]
net[, value := value / pop * 100]
net <- dcast(net[variable == "net"], region + year + agegroup + model ~ type, value.var = "value")
net[shp, geometry := i.geometry, on = .(region = AGS)]

## ggplot(net, aes(agegroup, actual, fill = agegroup)) +
##     geom_violin() +
##     ggtitle("Actual net migration rate: Net migration in % of pop of agegroup") +
##     theme_minimal()

```

```{r, coef-table, results = "show"}

kbl(dt_coefs, digits = 2, booktabs = TRUE, longtable = TRUE,
    caption = "Parameters")

```

```{r, kable-preds, results = "show"}

kbl(head(dt[order(actual)], 10),
    caption = "Predictions for smallest actual od-flows",
    digits = 2, booktabs = TRUE)
kbl(head(dt[order(- actual)], 10),
    caption = "Predictions for largest actual od-flows",
    digits = 2, booktabs = TRUE)

max_reg <- dt[actual == max(actual), .(fromdist, todist)]

## should have done a join
dt_sym1 <- dt[fromdist == max_reg[[1]] & todist == max_reg[[2]]]
dt_sym1[, type := "fromto"]
dt_sym2 <- dt[fromdist == max_reg[[2]] & todist == max_reg[[1]]]
dt_sym2[, type := "tofrom"]
dt_sym <- rbind(dt_sym1, dt_sym2)

dt_sym <- melt(dt_sym[, -c(1,2)],
     id.vars = c("agegroup", "year", "distance", "type"),
     value.var = c("preds", "actual"))

kbl(dcast(dt_sym, variable + type ~ agegroup, value.var = "value"),
    caption = "Are our predictions symmetric?",
    digits = 2, booktabs = TRUE)

```

## Maps
```{r make-maps, out.width = "99%"}

net[, diff := actual - preds]
netm <- melt(net,
             measure.vars = c("actual", "preds", "diff"),
             variable.name = "type")
##netm[, value := sign(value) * log(1 + abs(value))]

lapply(map_age, function(age) make_net_map(netm[agegroup == age & type %in% c("actual", "preds")]))

```

## Net chart
```{r net-plot}

make_net_plot(net, scales = "free") +
    facet_wrap(vars(agegroup))

make_net_plot(net, scales = "fixed") +
    coord_fixed()

ggplot(netm[type != "diff"], aes(value, fill = type)) +
    geom_density(alpha = .2) +
    facet_wrap(vars(agegroup), scales = "free") +
    ggtitle("Distribution of net migration rate") +
    theme_minimal()

```

## Individual Flows

```{r,}

dtm <- melt(dt, measure.vars = c("actual", "preds"))

ggplot(dtm, aes(log(value), color = variable)) +
    geom_density() +
    facet_wrap(vars(agegroup))

```

```{r individual-resids-violin}

sub1 <- sprintf("Residuals sign(resid) * log(1 + abs(resid)), only preds > %s are shown", preds_th)
resid_plt <- ggplot(dt[preds > preds_th],
                    aes(agegroup, resid2, fill = agegroup)) +
    geom_violin() +
    facet_wrap(vars(model))
prettify(resid_plt,
         main = "Individual Flows Residuals sign(resid) * log(1 + abs(resid))",
         sub = sub1)

sub2 <- sprintf("resid = (actual - preds) / preds, only preds > %s are shown", preds_th)
resid_plt <- ggplot(dt[preds > preds_th],
                    aes(agegroup, resid1, fill = agegroup)) +
    geom_violin() +
    facet_wrap(vars(model))
prettify(resid_plt, main = "Individual Flows",
         sub = sub2)

```

```{r, preds-resid, eval = TRUE}

plot_fit(dt, distance, log(actual/preds), 0) +
    facet_wrap(vars(agegroup, model), scale = "free", ncol = 2) 

plot_fit(dt, log(preds), log(actual/preds), 3, p_sample = .2)
plot_fit(dt, preds, (actual - preds) / preds, 3, 50, p_sample = .2) 
plot_fit(dt, preds, sign((actual - preds) / preds) * log(0 + ((actual - preds) / preds)) , 1, 50, p_sample = .2)

```

### Distance

```{r,}

plot_fit(dt, distance, log(actual/preds), 0, p_sample = .2)

```

### Population

```{r,}

plot_fit(dt, log(frompop * topop), log(actual/preds), 3, p_sample = .2)

```

### density
```{r, eval = TRUE}

dt[density, fromdens := i.density, on = .(fromdist = region, year)]
dt[density, todens := i.density, on = .(todist = region, year)]

plt1 <- plot_fit(dt, log(fromdens), log(actual/preds), 0, p_sample = .2)
plt2 <- plot_fit(dt, log(todens), log(actual/preds), 0, p_sample = .2)
plt3 <- plot_fit(dt, log(fromdens * todens), log(actual/preds), 0, p_sample = .2)

## plt1 + plt2
plt3

## dt[, sum(actual), keyby = .(agegroup)]


## plot_fit(dt[distance > 600], distance, log(actual / frompop), th_min = 0)


## dt[distance > 600, mean(actual == 0), keyby = .(agegroup)]

## dt[distance < 100, mean(actual), keyby = .(agegroup)]
## dt[distance > 600, .(avg = mean(actual)), keyby = .(agegroup)]
## dt[distance > 600 & actual > 0, .("avg log(actual / frompop)"
##                                   = mean(log(actual / frompop))), keyby = .(agegroup)]

## dt[distance > 600 & actual > 0, .("avg log(topop  / popgerm)" =
##                                       mean(log(topop / 73000))), keyby = .(agegroup)]

## dt[actual > 0, .("avg log(topop  / popgerm)" =
##                                       mean(log(topop / 73000))), keyby = .(agegroup)]


## plot_fit(dt[actual > 0], distance,
##          log(actual / frompop) - log(topop / 73000) ,
##          th_min = 0)
## ggsave("~/Desktop/plt.pdf")

## net1[, .(total_across_districts = sum(value)), keyby = variable]
## net1[variable == "net"][order(value), .(region, agegroup, type, variable, value)]


## dt[, .( allmoves = sum(actual)), keyby = .(agegroup)]

## age <- use_age[2]
## fit_gravity <- dt[agegroup == age, .(fit = .(glm(actual ~ log(frompop) + log(topop) + log(distance), family = poisson)))]
## fit_gravity[[1]]

## logistic <- function(x) {
##     1 / (1 + exp(-x))
## }

## logistic(4.5 / 1000)

```
