--- 
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
always_allow_html: true
---


```{r global_knitr, echo = FALSE, eval = TRUE}

knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      results = "hide",
                      fig.width = 8,
                      fig.asp = 0.7,
                      out.width = "120%")

```

```{r, packages}

library(data.table)
library(sf)
library(ggplot2)
library(MigStat)
library(plotR)
library(kableExtra)

source("functions.R")

```

```{r read-data, message = TRUE}

preds_th <- 3
age_lvls <- c("below18", "18-25", "25-30", "30-50", "50-65", "above65")
use_age <- age_lvls

data <- read_data("3_all_newrun_allflows")
dt <-setnames(data$preds, c("flows", "preds3"), c("actual", "preds"), skip_absent = TRUE)
dtm <- melt(dt, measure.vars = c("actual", "preds"))
## order_models(dt)
dt <- dt[agegroup %in% use_age]
dt[, agegroup := factor(agegroup, levels = age_lvls)]
dt[, resid1 := (actual - preds) / preds]
dt[, resid2 := sign(resid1) * log(1 + abs(resid1))]

### order_models(dt_coefs)
dt_coefs <- data$coefs
dt_coefs[, diff := values - inits]

p_clean <- "~/Diss/inst/extdata/clean/"
pop_dt <- fread(file.path(p_clean, "aux_data/age17for.csv"))
setnames(pop_dt, "age_group", "agegroup")
rec_ages(pop_dt)

shp <- setDT(sf::read_sf(file.path(p_clean, "shapes/districts_ext.shp")))
density <- data.table::fread(file.path(p_clean, "aux_data", "density.csv"))

```

```{r, diff-plt, fig.cap = caption}

caption <- "Distribution of differences between optimal values and initial values."

ggplot(dt_coefs, aes(values)) +
    geom_density() +
    facet_wrap(vars(model), scale = "free") +
    theme_minimal() +
    ggtitle("opti coefs")

ggplot(dt_coefs, aes(values - inits)) +
    geom_density() +
    facet_wrap(vars(model)) +
    theme_minimal() +
    ggtitle("opti - init")

```

```{r data}

## dt
dtm <- melt(dt, measure.vars = c("preds", "resid1", "resid2"), variable.name = "type")
dtm <- melt(dt, measure.vars = c("preds"), variable.name = "type")

net1 <- calculate_net(dt, col = "actual", by = c("year", "agegroup", "model"),
                      long = TRUE, type = "actual")
net2 <- calculate_net(dt, col = "preds", by = c("year", "agegroup", "model"),
                      long = TRUE, type = "preds")
net <- rbind(net1, net2)

net2 <- dcast(net[variable == "net"], region + year + agegroup ~ type)

net[pop_dt, pop := i.german, on = .(region, year, agegroup)]
net[, value := value / pop * 100] # in %, pop is in 1000
net <- dcast(net[variable == "net"], region + year + agegroup + model ~ type, value.var = "value")
net[shp, geometry := i.geometry, on = .(region = AGS)]

```

```{r, coef-table, results = "show"}

kbl(dt_coefs, digits = 2, booktabs = TRUE, longtable = TRUE,
    caption = "Parameters")

```

```{r, kable-preds, results = "show"}

kbl(head(dt[order(actual)], 10),
    caption = "Predictions for smallest actual od-flows",
    digits = 2, booktabs = TRUE)
kbl(head(dt[order(- actual)], 10),
    caption = "Predictions for largest actual od-flows",
    digits = 2, booktabs = TRUE)

max_reg <- dt[actual == max(actual), .(fromdist, todist)]

## should have done a join
dt_sym1 <- dt[fromdist == max_reg[[1]] & todist == max_reg[[2]]]
dt_sym1[, type := "fromto"]
dt_sym2 <- dt[fromdist == max_reg[[2]] & todist == max_reg[[1]]]
dt_sym2[, type := "tofrom"]
dt_sym <- rbind(dt_sym1, dt_sym2)

dt_sym <- melt(dt_sym[, -c(1,2)],
     id.vars = c("agegroup", "year", "distance", "type"),
     value.var = c("preds", "actual"))

kbl(dcast(dt_sym, variable + type ~ agegroup, value.var = "value"),
    caption = "Are our predictions symmetric?",
    digits = 2, booktabs = TRUE)

```

## Maps
```{r make-maps, out.width = "99%"}

net[, diff := actual - preds]
netm <- melt(net,
             measure.vars = c("actual", "preds", "diff"),
             variable.name = "type")
##netm[, value := sign(value) * log(1 + abs(value))]

lapply(use_age[c(1, 2)], function(age) make_net_map(netm[agegroup == age & type %in% c("actual", "preds")]))

```

## Net chart
```{r net-plot}

make_net_plot(net, scales = "free") +
    facet_wrap(vars(agegroup))

make_net_plot(net, scales = "fixed") +
    coord_fixed()

ggplot(netm[type != "diff"], aes(value, fill = type)) +
    geom_density(alpha = .2) +
    facet_wrap(vars(agegroup), scales = "free") +
    ggtitle("Distribution of net migration rate") +
    theme_minimal()

```

## Individual Flows

```{r,}

dtm <- melt(dt, measure.vars = c("actual", "preds"))

ggplot(dtm, aes(log(value), color = variable)) +
    geom_density() +
    facet_wrap(vars(agegroup))

```

```{r individual-resids-violin}

sub1 <- sprintf("Residuals sign(resid) * log(1 + abs(resid)), only preds > %s are shown", preds_th)
resid_plt <- ggplot(dt[preds > preds_th],
                    aes(agegroup, resid2, fill = agegroup)) +
    geom_violin() +
    facet_wrap(vars(model))
prettify(resid_plt,
         main = "Individual Flows Residuals sign(resid) * log(1 + abs(resid))",
         sub = sub1)

sub2 <- sprintf("resid = (actual - preds) / preds, only preds > %s are shown", preds_th)
resid_plt <- ggplot(dt[preds > preds_th],
                    aes(agegroup, resid1, fill = agegroup)) +
    geom_violin() +
    facet_wrap(vars(model))
prettify(resid_plt, main = "Individual Flows",
         sub = sub2)

```

```{r, preds-resid, eval = TRUE}

plot_fit(dt, distance, log(actual/preds), 0) +
    facet_wrap(vars(agegroup, model), scale = "free", ncol = 2) 

plot_fit(dt, log(preds), log(actual/preds), 3, p_sample = .2)
plot_fit(dt, preds, (actual - preds) / preds, 3, 50, p_sample = .2) 
plot_fit(dt, preds, sign((actual - preds) / preds) * log(0 + ((actual - preds) / preds)) , 1, 50, p_sample = .2)

```

### Distance

```{r,}

plot_fit(dt, distance, log(actual/preds), 0, p_sample = .2)

```

### Population

```{r,}

plot_fit(dt, log(frompop * topop), log(actual/preds), 3, p_sample = .2)

```

### density
```{r,}

dt[density, fromdens := i.density, on = .(fromdist = region, year)]
dt[density, todens := i.density, on = .(todist = region, year)]

plot_fit(dt, log(fromdens * todens), log(actual/preds), 3, p_sample = .2)

```
