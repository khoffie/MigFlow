---
title: Migration Distance How to model and why it matters
authors:
    name: Konstantin Hoffie
    affiliation: East-German
    roles: writing
    corresponding: true
engine: julia
execute:
  echo: false
  enabled: false
julia:
  exeflags: ["--project=/home/konstantin/code"]
  env: ["JULIA_NUM_THREADS=5"]
---

# Introduction
This document explains how to model the distance dependence of
migration flows; and how to estimate the fraction of distance
insensitive people.

```{julia}
#| label: libraries-functions
#| output: false

st(x) = supertype(typeof(x))

sr = true

using Revise, Distributions, StatsPlots, CSV, DataFrames, Random
using DataFramesMeta, Turing, SliceSampling, LogDensityProblems
using Serialization, Printf, Plots, Optimization, LaTeXStrings
using LinearAlgebra: I
using CategoricalArrays, ApproxFun, NamedArrays, KernelDensity, StatsBase
using Interpolations

include("../src/loadgermdata.jl")
include("estimate.jl")
include("models.jl")
include("models_utils.jl")
include("diag.jl")
include("diagplots.jl")

```

```{julia}
#| label: load-data

ages = ["below18", "18-25", "25-30","30-50", "50-65", "above65"]
flows = read_flows("../data/FlowDataGermans.csv", .1, ages, 2000:2017)
flows = flows[(flows.agegroup .== "30-50") .& (flows.year .== 2017), :]

districts = CSV.read("../data/districts.csv", DataFrame)
add_lrd(districts)
flows = joinlrd(flows, districts)

```

## Populations

```{julia}

function plot_flows(df, groupcol, popcol)
    df = combine(groupby(df, groupcol), :flows => sum, popcol => unique)
    df = df[df.flows_sum .> 0, :]
    sp = string(popcol)
    scatter(log.(df[!,  sp * "_unique"]),
            log.(df.flows_sum),
            label = "", xlab = "log $sp")
end

function plot_totalflux(df)
    a = string(unique(df.agegroup)[1])
    y = string(unique(df.year)[1])
    p1 = plot(plot_flows(df, :fromdist, :frompop), ylab = "total outflux")
    p2 = plot(plot_flows(df, :todist, :topop), ylab = "total influx")
    plot(p1, p2, plot_title = "Populations and total flux\n$a, $y",
         plot_titlevspan = .2)
end

plot_totalflux(flows)

```

Intuitively distance matters because a greated distance brings with it
certain inconveniences. The further I move the further I am away from
my friends and family, the more I have to adept to a new city, new
culture etc. Empirically it is also clear that distance is a very
important factor, inhibiting migrations.

A well established model to account for distance dependence is the
gravity model, which assumes that flows $Y$ from origin to destination
$Y_{od}$ are proportional to $1 / D^c$ where $D$ is the distance
between origin and destination and c is a parameter to be estimated.

```{julia}
#| label: distance-kde

#| fig.cap: caption

caption = "Observed distribution of migration distances and expected distribution if migrants would not respond to distance (expected). Both curves were obtained by a kernel density estimation. For the expected curve we assumed that people pick a destination randomly, with a probability proportional to it's population. The other three curves model the dependence on distance but differ in their assumptions. Gravity assumes a power law decay, linear assumes a linear decay and mixture assumes there are two populations: Distance sensitive, modeled as power law decay and distance insensitive, who do not respond to distance at all."

function fitdistance(flows)
    outgravity = estimate(gravity, flows, 100, [-20, 10], [0, 100]);
    flows.gravity = outgravity[3];

    # outlinear = estimate(linear, flows, 100, [-20, 0, 1], [0, 100, 1000]);
    # flows.linear = outlinear[3];

    outmixture = estimate(distonly, flows, 100);
    flows.mixture = outmixture[3];
    return flows
end
    
function plot_distances(flows::DataFrame, kernel::UnivariateDistribution)    
    p = distance_kde(flows.dist, flows.flows, kernel, "Observed", false)
    # distance_kde(flows.dist, flows.frompop .* flows.topop, kernel,
    #              "Expected", true)
    distance_kde(flows.dist, flows.gravity, kernel, "Gravity", true)
    # distance_kde(flows.dist, flows.linear, kernel, "Linear", true)
    distance_kde(flows.dist, flows.mixture, kernel, "Mixture", true)
    age = unique(flows.agegroup)[1]
    year = unique(flows.year)[1]
    plot!(title = "$age")
    return p
end

function plot_distances(flows, year)
    p = plot()
    for g in groupby(flows[flows.year .== year, :], :agegroup)
        age = unique(g.agegroup)[1]
        p = distance_kde(g.dist, g.flows,
                         Normal(0, 20), "$age", true)
        display(p)
    end
    p = plot(p, title = "$year")
    return p
end

distplots = [plot_distances(flows, y) for y in 2000:2017]

p = plot(distplots[[1, 5, 10, 12, 15, 18]]...,
         plot_title = "Observed Migration Distances",
         size = (1200, 800),
         layout = (2, 3))

df = flows[flows.year .== 2017 && flows.agegroup .== "18-25"]
args = Dict(
    :fp => 
) 


```

The above suggests that assuming two populations —distance sensitive
and distance insensitive— better describes the data. From a
theoretical perspective it helps to explain surprising facts about
reality: Why the decay is so fast between 50 and 200km and why at the
same time relatively many migrate across distances of 300km and more.

```{julia}
#| label: fraction-insensitive
#| output: false
#| fig.cap: Fraction of distance insensitive moves as function of distance, in percent.

function estimate_l(model, flows)
    ## below 1 causes problems, probably because l then is very close
    ## to 0
    dscales = [1 : 1 : 10; 11 : 10 : 201; 202 : 50 : 803]
    ## All these models should lead to the same fit, since only the
    ## scaling of distance is changed. Parameter estimates correspond
    ## to dist / distscale = 1. Due to numerical issues the fit may be
    ## very poor and thus the estimates may not be trusted. It is
    ## probably a good idea to disregard those fits.
    l = [estimate(model, flows, ds)[1]["l"] for ds in dscales]
    res = DataFrame(dist = dscales, l = l)
    p = plot(res.dist, res.l, label = "",
             xlab = "Distance in km",
             ylab = "Fraction",
             title = "Fraction of distance insensitive moves")
    display(p)
    return res, p
end

flows, geog = load_data("../data", 0.2);
res, p = estimate_l(distonly, flows);
display(p)

```

```{julia}
#| label: predictl

logistic(x, a, b, c = 0, L = 1) = L ./ (1 .+ exp.( .- (a .+ b .* (x  .- c))))

function plotlogreg(res, chn)
    plot(res.dist, res.l, label = "l estimated in mixture model")
    a = mean(chn[:a][700:end])
    b = mean(chn[:b][700:end])
    c = mean(chn[:c][700:end])
    regline = logistic(res.dist, a, b, c, 100)
    plot!(res.dist, regline,
          title = "l: Fraction of distance insensitive",
          xlab = "Distance in km",
          ylab = "l, Fraction of insensitive",
          label = "l explained in logistic regression")
end

@model function predict_l(dist, l)
    a ~ Normal(0, 5)
    b ~ Normal(0, 5)
    s ~ Gamma(1, 1)

    l = log.(l)
    m = logistic(dist, a, b, 0, 1)
    l ~ arraydist(Normal.(m, s))
    return m
end


mdl = predict_l(res.dist, res.ratio)
chn = Turing.sample(mdl, NUTS(), 1000)
plot(chn)
res.preds = generated_quantities(mdl, chn[end, :, :])[1]
plot(res.dist, res.preds)
res
chn
plotlogreg(res, chn)

res.ratio = res.l ./ (100.0 .- res.l)
plot(res.dist, res.ratio)
plot!(res.dist, res.l)
```

Let's now estimate the fraction of distance insensitve migrants in the
population. That is, each migrant $i_{od}$ belongs either to distance
sensitive migrants $S$ or to distance insensitive migrants $S^c$ and
we want to estimate $P(i \in S^c)$. The fraction of insensitive
migrants at a certain distance, $\hat{l}$, is an estimate for the true
fraction of insensitive migrants at a certain distance, $l := P(i \in
S^c | D(i) = x)$. Thus, $l$ is a conditional probability and by
integrating over $[D_1, D_2]$ we can estimate how many migrants that
moved between $D_1$ and $D_2$km are insensitive.

$$
\int_{D_1}^{D_2}l_i(x)dP_D(x) = \int_{D_1}^{D_2}l_i(x)f(x)dx 
$$

where $f$ is the density of $D$. Of particular interest is the
integral over $[\min(D), \max(D)]$ since this estimates the fraction
of insensitive migrants.

```{julia}

interp = linear_interpolation(Float64.(res.dist), res.l)
weights = flows.flows ./ sum(flows.flows)
di = StatsBase.wsample(flows.dist, weights, 10^3)

function plotfrac(l::AbstractExtrapolation, di::Vector{Int};
                  dmin::Signed = minimum(di),
                  dmax::Signed = maximum(di),
                  add::Bool = true, lbl::String = "")
    frac = l.(di[di .> dmin .&& di .< dmax])
    f = add == true ? plot! : plot
    p = f(kde(frac), label = lbl)
    display(p)
    return frac
end

```

```{julia}
#| label: calc-frac-2017

function retinterp(model, age::String, year::Int)
    println("Starting interpolation for $age and $year")
    flows, geog = load_data("../data", 0.1, age, year);
    res, p = estimate_l(model, flows)
    interp = linear_interpolation(Float64.(res.dist), res.l)
    return res.dist, res.l, interp
end

results = [(agegroup = g, out = retinterp(distonly, g, 2017)) for g in ages]

p = plot()
results[1].interp
[plotfrac(results[i].out[3], di, lbl = results[i].agegroup)
 for i in eachindex(results)]

p = plot(xlab = "Distance in km", ylab = "Fraction of insensitve, %")
[plot!(results[i].out[1],
       results[i].out[2],
       label = results[i].agegroup) for i in eachindex(ages)]
p

p = plot(xlab = "Fraction of insensitive", ylab = "Density")
[plotfrac(results[i].out[3], di, lbl = results[i].agegroup) for i in eachindex(ages)]


```

## Estimate model with density

```{julia}



args = Dict(
    :flows => flows.flows,
    :fp => flows.frompop,
    :tp => flows.topop,
    :di => flows.dist
)

grav = estimate(gravity, args, [-20, 10], [0, 100])
grav[1]


function fitdistdens(model, flows, ndc)
    args = Dict(
        :flows => flows.flows,
        :fp => flows.frompop,
        :tp => flows.topop,
        :di => flows.dist,
        :fd => flows.fromdens,
        :td => flows.todens,
        :ndenscoefs => ndc,
        :densmin => minimum(flows.fromdens),
        :densmax => maximum(flows.todens)
    )

    ## a, c, l, d0, kd
    lb = [-20, 10, 0, 1, fill(-10, ndc)...]
    ub = [0, 100, 99, 100, fill(10, ndc)...]
    out = estimate(model, args, lb, ub)
    kds = out[1][startswith.(names(out[1])[1], "kd")]
    evaldensitycheby(kds, args[:densmin], args[:densmax])
    return out
end

out = fitdistdens(distdens, flows, 2)
out[1]

```

